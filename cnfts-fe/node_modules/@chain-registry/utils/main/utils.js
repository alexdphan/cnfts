"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ibcDenom = exports.getWasmChannel = exports.getTransferChannel = exports.getNonTransferChannel = exports.getIbcInfo = exports.getIbcDenomByBase = exports.getIbcAssets = exports.getIbcAssetPath = exports.getCw20Assets = exports.getAssetLists = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _sha = require("sha.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var ibcDenom = function ibcDenom(paths, coinMinimalDenom) {
  var prefixes = [];
  var _iterator = _createForOfIteratorHelper(paths),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var path = _step.value;
      prefixes.push("".concat(path.port_id, "/").concat(path.channel_id));
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var prefix = prefixes.join('/');
  var denom = "".concat(prefix, "/").concat(coinMinimalDenom);
  return 'ibc/' + Buffer.from(new Uint8Array(new _sha.sha256().update(Buffer.from(denom)).digest())).toString('hex').toUpperCase();
};
exports.ibcDenom = ibcDenom;
var findInfo = function findInfo(ibc, to, from) {
  return ibc.find(function (i) {
    return i.chain_1.chain_name === from && i.chain_2.chain_name === to;
  });
};
var getIbcInfo = function getIbcInfo(ibc, chain, counterparty) {
  return findInfo(ibc, chain, counterparty) || findInfo(ibc, counterparty, chain);
};
exports.getIbcInfo = getIbcInfo;
var getTransferChannel = function getTransferChannel(info) {
  return info.channels.find(function (channel) {
    return channel.chain_1.port_id === 'transfer' && channel.chain_2.port_id === 'transfer';
  });
};
exports.getTransferChannel = getTransferChannel;
var getNonTransferChannel = function getNonTransferChannel(info) {
  return info.channels.find(function (channel) {
    return channel.chain_1.port_id !== 'transfer' && channel.chain_2.port_id === 'transfer' || channel.chain_1.port_id === 'transfer' && channel.chain_2.port_id !== 'transfer';
  });
};
exports.getNonTransferChannel = getNonTransferChannel;
var getWasmChannel = function getWasmChannel(info) {
  return info.channels.find(function (channel) {
    return channel.chain_1.port_id.startsWith('wasm.') && channel.chain_2.port_id === 'transfer' || channel.chain_1.port_id === 'transfer' && channel.chain_2.port_id.startsWith('wasm');
  });
};
exports.getWasmChannel = getWasmChannel;
var getIbcAssetPath = function getIbcAssetPath(ibc, chain, counterparty, assets, base) {
  var _asset$traces$filter, _asset$traces, _asset$traces$filter2;
  var ibcInfo = getIbcInfo(ibc, chain, counterparty);
  if (!ibcInfo) {
    return [];
  }
  var channel = base.startsWith('cw20:') ? getWasmChannel(ibcInfo) : getTransferChannel(ibcInfo);
  if (!channel) {
    return [];
  }
  var channelInfo;
  if (ibcInfo.chain_1.chain_name === chain) {
    channelInfo = channel.chain_1;
  } else {
    channelInfo = channel.chain_2;
  }
  var memo = [channelInfo];
  var assetList = assets.find(function (_ref) {
    var chain_name = _ref.chain_name;
    return chain_name === counterparty;
  });
  if (!assetList) {
    return memo;
  }
  var asset = assetList.assets.find(function (asset) {
    return asset.base === base;
  });
  if (!asset) {
    console.log("no ".concat(base, " found in ").concat(counterparty));
    return memo;
  }
  var traces = (_asset$traces$filter = (_asset$traces = asset.traces) === null || _asset$traces === void 0 ? void 0 : (_asset$traces$filter2 = _asset$traces.filter) === null || _asset$traces$filter2 === void 0 ? void 0 : _asset$traces$filter2.call(_asset$traces, function (trace) {
    return trace.type === 'ibc' || trace.type === 'ibc-cw20';
  })) !== null && _asset$traces$filter !== void 0 ? _asset$traces$filter : [];
  if (!traces.length) {
    return memo;
  }
  if (traces.length > 1) {
    throw new Error('contact maintainers: multi-hop not yet supported');
  }
  var _traces = (0, _slicedToArray2["default"])(traces, 1),
    trace = _traces[0];
  return [].concat(memo, (0, _toConsumableArray2["default"])(getIbcAssetPath(ibc, counterparty, trace.counterparty.chain_name, assets, trace.counterparty.base_denom
  // base
  )));
};
exports.getIbcAssetPath = getIbcAssetPath;
var getIbcDenomByBase = function getIbcDenomByBase(ibc, chain, counterparty, assets, base) {
  var ibcInfo = getIbcInfo(ibc, chain, counterparty);
  if (ibcInfo) {
    var _asset$traces2, _asset$traces2$find, _ibcTrace$counterpart, _ibcTrace$counterpart2;
    var channel = base.startsWith('cw20:') ? getWasmChannel(ibcInfo) : getTransferChannel(ibcInfo);
    if (!channel) {
      return;
    }
    var ibcPath = getIbcAssetPath(ibc, chain, counterparty, assets, base);
    var assetList = assets.find(function (_ref2) {
      var chain_name = _ref2.chain_name;
      return chain_name === counterparty;
    });
    if (!assetList) {
      console.warn("missing asset list for ".concat(counterparty));
      // could be incorrect...
      return ibcDenom(ibcPath, base);
    }
    var asset = assetList.assets.find(function (asset) {
      return asset.base === base;
    });
    if (!asset) {
      console.warn("no ".concat(base, " found in ").concat(counterparty));
      return ibcDenom(ibcPath, base);
    }
    var ibcTrace = (_asset$traces2 = asset.traces) === null || _asset$traces2 === void 0 ? void 0 : (_asset$traces2$find = _asset$traces2.find) === null || _asset$traces2$find === void 0 ? void 0 : _asset$traces2$find.call(_asset$traces2, function (trace) {
      return trace.type === 'ibc';
    });
    var baseDenom = (_ibcTrace$counterpart = ibcTrace === null || ibcTrace === void 0 ? void 0 : (_ibcTrace$counterpart2 = ibcTrace.counterparty) === null || _ibcTrace$counterpart2 === void 0 ? void 0 : _ibcTrace$counterpart2.base_denom) !== null && _ibcTrace$counterpart !== void 0 ? _ibcTrace$counterpart : asset.base;
    return ibcDenom(ibcPath, baseDenom);
  }
};
exports.getIbcDenomByBase = getIbcDenomByBase;
var getIbcAssets = function getIbcAssets(chainName, ibc, assets) {
  var chainIbcInfo = ibc.filter(function (i) {
    return i.chain_1.chain_name === chainName || i.chain_2.chain_name === chainName;
  });
  var ibcAssetLists = chainIbcInfo.map(function (ibcInfo) {
    var counterpartyIs = ibcInfo.chain_1.chain_name === chainName ? 'chain_2' : 'chain_1';
    var chainIs = ibcInfo.chain_1.chain_name === chainName ? 'chain_1' : 'chain_2';
    var counterparty = ibcInfo[counterpartyIs].chain_name;
    var counterpartyIbc = ibcInfo[counterpartyIs];
    var chainIbc = ibcInfo[chainIs];
    var counterpartyAssets = assets.find(function (a) {
      return a.chain_name === counterparty;
    });
    if (!counterpartyAssets) {
      // console.warn('asset not found: ' + counterparty);
      return;
    }
    var ibcAssets = counterpartyAssets.assets.filter(function (a) {
      return !a.base.startsWith('cw20:');
    }).map(function (asset) {
      var denom = getIbcDenomByBase(ibc, chainName, counterparty,
      //
      assets, asset.base);
      var newAsset = _objectSpread({}, asset);
      newAsset.base = denom;
      newAsset.denom_units = newAsset.denom_units.map(function (unit) {
        if (unit.denom === asset.base) {
          var newUnit = _objectSpread({}, unit);
          newUnit.denom = denom;
          newUnit.aliases = [unit.denom];
          return newUnit;
        }
        return unit;
      });
      return newAsset;
    });
    var channel = getTransferChannel(ibcInfo);
    return {
      chain: _objectSpread(_objectSpread({}, chainIbc), channel[chainIs]),
      counterparty: _objectSpread(_objectSpread({}, counterpartyIbc), channel[counterpartyIs]),
      assets: ibcAssets
    };
  }).filter(Boolean);
  var hash = ibcAssetLists.reduce(function (m, v) {
    m[v.chain.chain_name] = m[v.chain.chain_name] || [];
    var assets = v.assets.map(function (asset) {
      return _objectSpread(_objectSpread({}, asset), {}, {
        traces: [{
          type: 'ibc',
          counterparty: {
            // source_channel
            channel_id: v.counterparty.channel_id,
            // source_denom
            base_denom: asset.denom_units[0].aliases[0],
            chain_name: v.counterparty.chain_name
            // port: v.counterparty.port_id
          },

          chain: {
            // dst_denom
            channel_id: v.chain.channel_id
            // chain_name: v.chain.chain_name,
            // port: v.chain.port_id
          }
        }]
      });
    });

    var obj = _objectSpread(_objectSpread({}, v), {}, {
      assets: assets
    });
    m[v.chain.chain_name].push(obj);
    return m;
  }, {});
  return Object.keys(hash).map(function (chain) {
    return {
      chain_name: chain,
      assets: hash[chain].reduce(function (m, v) {
        return [].concat((0, _toConsumableArray2["default"])(m), (0, _toConsumableArray2["default"])(v.assets));
      }, [])
    };
  });
};
exports.getIbcAssets = getIbcAssets;
var getCw20Assets = function getCw20Assets(chainName, ibc, assets) {
  var chainIbcInfo = ibc.filter(function (i) {
    return i.chain_1.chain_name === chainName || i.chain_2.chain_name === chainName;
  });
  var cw20AssetLists = chainIbcInfo.map(function (ibcInfo) {
    var counterpartyIs = ibcInfo.chain_1.chain_name === chainName ? 'chain_2' : 'chain_1';
    var chainIs = ibcInfo.chain_1.chain_name === chainName ? 'chain_1' : 'chain_2';
    var counterparty = ibcInfo[counterpartyIs].chain_name;
    var counterpartyIbc = ibcInfo[counterpartyIs];
    var chainIbc = ibcInfo[chainIs];
    var counterpartyAssets = assets.find(function (a) {
      return a.chain_name === counterparty;
    });
    if (!counterpartyAssets) {
      // console.warn('asset not found: ' + counterparty);
      return;
    }
    var cw20Assets = counterpartyAssets.assets.filter(function (a) {
      return a.base.startsWith('cw20:');
    }).map(function (asset) {
      var denom = getIbcDenomByBase(ibc, chainName, counterparty,
      //
      assets, asset.base);
      var newAsset = _objectSpread({}, asset);
      newAsset.base = denom;
      newAsset.denom_units = newAsset.denom_units.map(function (unit) {
        if (unit.denom === asset.base) {
          var newUnit = _objectSpread({}, unit);
          newUnit.denom = denom;
          newUnit.aliases = [unit.denom];
          return newUnit;
        }
        return unit;
      });
      return newAsset;
    });
    if (!cw20Assets.length) return;
    var channel = getWasmChannel(ibcInfo);
    if (!channel) {
      // console.warn(
      //   chainIbc.chain_name,
      //   '<>',
      //   counterpartyIbc.chain_name,
      //   'MISSING cw20 IBC info'
      // );
      return;
    }
    return {
      chain: _objectSpread(_objectSpread({}, chainIbc), channel[chainIs]),
      counterparty: _objectSpread(_objectSpread({}, counterpartyIbc), channel[counterpartyIs]),
      assets: cw20Assets
    };
  }).filter(Boolean);
  var hash = cw20AssetLists.reduce(function (m, v) {
    m[v.chain.chain_name] = m[v.chain.chain_name] || [];
    var assets = v.assets.map(function (asset) {
      return _objectSpread(_objectSpread({}, asset), {}, {
        traces: [{
          type: 'ibc-cw20',
          counterparty: {
            port: v.counterparty.port_id,
            // source_channel
            channel_id: v.counterparty.channel_id,
            // source_denom
            base_denom: asset.denom_units[0].aliases[0],
            chain_name: v.counterparty.chain_name
          },
          chain: {
            // dst_denom
            port: v.chain.port_id,
            channel_id: v.chain.channel_id
            // chain_name: v.chain.chain_name,
          }
        }]
      });
    });

    var obj = _objectSpread(_objectSpread({}, v), {}, {
      assets: assets
    });
    m[v.chain.chain_name].push(obj);
    return m;
  }, {});
  return Object.keys(hash).map(function (chain) {
    return {
      chain_name: chain,
      assets: hash[chain].reduce(function (m, v) {
        return [].concat((0, _toConsumableArray2["default"])(m), (0, _toConsumableArray2["default"])(v.assets));
      }, [])
    };
  });
};
exports.getCw20Assets = getCw20Assets;
var getAssetLists = function getAssetLists(chainName, ibc, assets) {
  var ibcAssetLists = getIbcAssets(chainName, ibc, assets);
  var cw20Assets = getCw20Assets(chainName, ibc, assets);
  return ibcAssetLists.reduce(function (m, v) {
    var chain = v.chain_name;
    var assets = (0, _toConsumableArray2["default"])(v.assets);
    var cw20 = cw20Assets.find(function (a) {
      return a.chain_name === chain;
    });
    if (cw20) {
      [].push.apply(assets, cw20.assets);
    }
    return [{
      chain_name: chain,
      assets: assets
    }].concat((0, _toConsumableArray2["default"])(m));
  }, []);
};
exports.getAssetLists = getAssetLists;